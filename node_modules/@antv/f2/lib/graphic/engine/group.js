"use strict";

exports.__esModule = true;
exports["default"] = void 0;

var _common = require("../../util/common");

var _rect = _interopRequireDefault(require("./shape/rect"));

var _container = _interopRequireDefault(require("./container"));

var _vector = _interopRequireDefault(require("../util/vector2"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Group = /*#__PURE__*/function (_Rect) {
  _inheritsLoose(Group, _Rect);

  function Group() {
    return _Rect.apply(this, arguments) || this;
  }

  var _proto = Group.prototype;

  _proto._initProperties = function _initProperties() {
    this._attrs = {
      type: 'group',
      zIndex: 0,
      visible: true,
      destroyed: false,
      isGroup: true,
      canFill: true,
      canStroke: true,
      attrs: {},
      children: []
    };
  };

  _proto.getBBox = function getBBox() {
    var self = this;
    var minX = Infinity;
    var maxX = -Infinity;
    var minY = Infinity;
    var maxY = -Infinity;
    var children = self.get('children');

    for (var i = 0, length = children.length; i < length; i++) {
      var child = children[i];

      if (child.get('visible')) {
        var box = child.getBBox();

        if (!box) {
          continue;
        }

        var leftTop = [box.minX, box.minY];
        var leftBottom = [box.minX, box.maxY];
        var rightTop = [box.maxX, box.minY];
        var rightBottom = [box.maxX, box.maxY];
        var matrix = child.attr('matrix');

        _vector["default"].transformMat2d(leftTop, leftTop, matrix);

        _vector["default"].transformMat2d(leftBottom, leftBottom, matrix);

        _vector["default"].transformMat2d(rightTop, rightTop, matrix);

        _vector["default"].transformMat2d(rightBottom, rightBottom, matrix);

        minX = Math.min(leftTop[0], leftBottom[0], rightTop[0], rightBottom[0], minX);
        maxX = Math.max(leftTop[0], leftBottom[0], rightTop[0], rightBottom[0], maxX);
        minY = Math.min(leftTop[1], leftBottom[1], rightTop[1], rightBottom[1], minY);
        maxY = Math.max(leftTop[1], leftBottom[1], rightTop[1], rightBottom[1], maxY);
      }
    }

    return {
      minX: minX,
      minY: minY,
      maxX: maxX,
      maxY: maxY,
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    };
  };

  _proto.createPath = function createPath(context) {
    var attrs = this.get('attrs'); // 只有在有fillStyle或strokeStyle 时才需要绘制

    if (!attrs.fillStyle && !attrs.strokeStyle) {
      return;
    }

    _Rect.prototype.createPath.call(this, context);
  };

  _proto.drawInner = function drawInner(context) {
    _Rect.prototype.drawInner.call(this, context);

    this.drawChildren(context);
  };

  _proto.destroy = function destroy() {
    if (this.get('destroyed')) {
      return;
    }

    this.clear();

    _Rect.prototype.destroy.call(this);
  };

  return Group;
}(_rect["default"]);

(0, _common.mix)(Group.prototype, _container["default"], {
  getGroupClass: function getGroupClass() {
    return Group;
  }
});
var _default = Group;
exports["default"] = _default;